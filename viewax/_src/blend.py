from __future__ import annotations
from typing import Callable

import jax.numpy as jnp
import chex

from .utils import flatten, unflatten


def blend_image(
    rng: chex.PRNGKey,
    img1: chex.Array,
    img2: chex.Array,
    mask_fn: Callable[[chex.PRNGKey, tuple[int, int, int]], chex.Array],
) -> tuple[chex.Array, chex.Array]:
    """Blend two images by the masks generated by mask_fn.

    Args:
        rng (PRNGKey): A PRNG key.
        img1 (array): An image array to blend.
        img2 (array): An image array to blend.
        mask_fn: A function to generate the blend masks.

    Returns:
        Blended images and sampled masks. The output is float32 array in [0, 255].

    Examples:
        >>> # CutOut
        >>> import viewax
        >>> mask_fn = viewax.masks.cutout(...)
        >>> img, masks = viewax.blend_image(rng, img1, jax.random.uniform(...), mask_fn)

        >>> # CutMix
        >>> img, masks = viewax.blend_image(rng, img1, img2, mask_fn)
        >>> # Compute average of masks to obtain mixed labels.
        >>> p = jnp.mean(masks, (1, 2, 3)).reshape(-1, 1)
        >>> label = p * label1 + (1-p) * label2

        >>> # Mixup
        >>> mask_fn = viewax.masks.mixup(alpha=0.5)
        >>> img, masks = viewax.blend_image(rng, img1, img2, mask_fn)
        >>> p = jnp.mean(masks, (1, 2, 3)).reshape(-1, 1)
        >>> label = p * label1 + (1-p) * label2
    """
    img1, original_image = flatten(img1)
    img2, _ = flatten(img2)

    img1, img2 = jnp.float32(img1), jnp.float32(img2)

    batch_size, height, width, _ = img1.shape
    masks = mask_fn(rng, (batch_size, height, width))
    degenerate = masks * img1 + (1 - masks) * img2

    return unflatten(degenerate, original_image), masks
